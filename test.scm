(define true (= 0 0))
(define false (= 1 0))
(define (list-len lst)
 (define (iter L len)
  (if (null? L) len
   (iter (cdr L) (+ len 1))))
 (iter lst 0))

(display (list-len (list 1 2 3)))
(newline)
(define (memq item x)
 (cond ((null? x) false)
  ((eq? item (car x)) x)
  (else (memq item (cdr x)))))

(display (memq 'apple '(pear banana apple orange)))
(newline)

(define (equal? la lb)
 (cond ((and (null? la) (null? lb)) true)
  ((and (not (null? la)) (not (null? lb)))
   (let ((la-a (car la))
	   (lb-a (car lb)))
	(and ((if (pair? la-a) equal? eq?) la-a lb-a) 
	 (equal? (cdr la) (cdr lb)))))
  (else false)))
   
(display (if (equal? '(this is a list) '(this is a list)) 
		  "equal" "not equal"))
(newline)

(display (if (equal? '(this is a list) '(this '(is a) list)) 
		  "equal" "not equal"))
(newline)

(define (variable? x) (symbol? x))
(define (same-variable? x y)
 (and (variable? x) (variable? y) (eq? x y)))
(define (=number? expr n)
 (and (number? expr) (= expr n)))

(define (make-sum a b) 
 (cond ((=number? a 0) b)
  ((=number? b 0) a)
  ((and (number? a) (number? b)) (+ a b))
  (else (list '+ a b))))

(define (make-product a b)
 (cond ((or (=number? a 0) (=number? b 0)) 0)
  ((eq? a '1) b)
  ((eq? b '1) a)
  ((and (number? a) (number? b)) (* a b))
  (else (list '* a b))))
(define (sum? x)
 (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (addgend s) 
 (if (> (list-len s) 3)
  (append (list '+) (cddr s))
  (caddr s)))
(define (product? x)
 (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p)
 (if (> (list-len p) 3)
  (append (list '*) (cddr p))
  (caddr p)))

(define (exponentiation? expr)
 (eq? (car expr) '**))
(define (base expr) (cadr expr))
(define (exponent expr) (caddr expr))
(define (make-exponentiation bs expn)
 (cond ((=number? expn 0) 1)
  ((=number? expn 1) bs)
  (else (list '** bs expn))))

(define (deriv expr var)
 (cond ((number? expr) 0)
  ((variable? expr)
   (if (same-variable? expr var) 1 0))
  ((sum? expr) 
   (make-sum (deriv (addend expr) var)
	(deriv (addgend expr) var)))
  ((product? expr)
   (make-sum (make-product (multiplier expr)
			  (deriv (multiplicand expr) var))
	(make-product (deriv (multiplier expr) var)
	 (multiplicand expr))))
  ((exponentiation? expr)
   (let ((bs (base expr))
		 (expn (exponent expr)))
	(make-product 
	 (make-product expn (make-exponentiation bs (make-sum expn (- 1))))
	 (deriv bs var))))
  (else (display "unknown expression type!")
   (newline))))

(display "======== deriv test =========")
(newline)
(display (deriv '(+ x 3) 'x))
(newline)
(display (deriv '(* x y) 'x))
(newline)
(display (deriv '(* (* x y) (+ x 3)) 'x ))
(newline)

(display (deriv '(+ (** (+ (** x 3) (* x y)) 2) (* x y)) 'x))
(newline)

(display (deriv '(* x y (+ x 3)) 'x))
(newline)
