(define true (= 0 0))
(define false (= 1 0))
(define (list-len lst)
 (define (iter L len)
  (if (null? L) len
   (iter (cdr L) (+ len 1))))
 (iter lst 0))

(define (memq item x)
 (cond ((null? x) false)
  ((eq? item (car x)) x)
  (else (memq item (cdr x)))))

(define (equal? la lb)
 (cond ((and (null? la) (null? lb)) true)
  ((and (not (null? la)) (not (null? lb)))
   (let ((la-a (car la))
	   (lb-a (car lb)))
	(and ((if (pair? la-a) equal? eq?) la-a lb-a) 
	 (equal? (cdr la) (cdr lb)))))
  (else false)))

(define (variable? x) (symbol? x))
(define (same-variable? x y)
 (and (variable? x) (variable? y) (eq? x y)))
(define (=number? expr n)
 (and (number? expr) (= expr n)))

; For not fully parenthesized expressions,
; we should be able to detect the situation below :
;     (x * 3 + (x + y + 1)) in terms of x
; So we can transform those ones which are not fully
; parenthesized expressions into the fully parenthesized ones
; before we do the deriv 
(define (sum? expr)
 (and (pair? expr) (eq? (cadr expr) '+)))
(define (addend expr) (car expr))
(define (addgend expr) 
 (if (> (list-len expr) 3)
  (cddr expr)
  (caddr expr)))
(define (make-sum a b)
 (cond ((=number? a 0) b)
  ((=number? b 0) a)
  ((and (number? a) (number? b)) (+ a b))
  (else (list a '+ b))))

(define (product? expr)
 (and (pair? expr) (eq? (cadr expr) '*)))
(define (multiplier expr) (car expr))
(define (multiplicand expr)
 (if (> (list-len expr) 3)
  (cddr expr)
  (caddr expr)))
(define (make-product a b)
 (cond ((or (=number? a 0) (=number? b 0)) 0)
  ((=number? a 1) b)
  ((=number? b 1) a)
  (else (list a '* b))))

(define (exponentiation? expr)
 (and (pair? expr) (eq? (cadr expr) '**)))
(define (base expr) (car expr))
(define (exponent expr) (caddr expr))
(define (make-exponentiation bs expo)
 (cond ((=number? expo 0) 1)
  ((=number? expo 1) bs)
  (else (list bs '** expo))))

; differentiation procedure
(define (deriv expr var)
 (cond ((number? expr) 0)
  ((variable? expr)
   (if (same-variable? expr var) 1 0))
  ((sum? expr) 
   (make-sum (deriv (addend expr) var)
	(deriv (addgend expr) var)))
  ((product? expr)
   (if (and (> (list-len expr) 3)
		(eq? (cadddr expr) '+))
	(deriv (append (list (list (car expr) (cadr expr) (caddr expr)))
			(cdddr expr)) var)
	(make-sum (make-product (multiplier expr)
			  (deriv (multiplicand expr) var))
	 (make-product (deriv (multiplier expr) var)
	  (multiplicand expr)))))
  ((exponentiation? expr)
   (let ((bs (base expr))
		 (expn (exponent expr)))
	(make-product 
	 (make-product expn (make-exponentiation bs (make-sum expn (- 1))))
	 (deriv bs var))))
  (else (display "unknown expression type!")
   (newline))))

(display (deriv '(x + 3 * (x + y + 2)) 'x))
(newline)
(display (deriv '(x + 3) 'x))
(newline)
(display (deriv '(x * y) 'x))
(newline)
(display (deriv '(x * y * (x + 3)) 'x))
(newline)
(display (deriv '((((x ** 3) + (x * y)) ** 2) + (x * y)) 'x))
(newline)
(display (deriv '(x * 3 + (x + y + 2)) 'x))
(newline)
(display (deriv '(x * ((x ** 2) + 2) + 3 * (x ** 3) * (x * y + (y ** 2))) 'x))
(newline)
(display (deriv '(x * ((x * y + 1) * x + 3 * x * y) + 2 * x * y) 'x))
(newline)

